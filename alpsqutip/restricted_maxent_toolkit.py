import qutip as qutip
import numpy as np
import scipy.linalg as linalg
from typing import Callable, Optional, Tuple
import datetime

import sys
from alpsqutip.proj_evol import (
    safe_exp_and_normalize,
)  ## function used to safely and robustly map K-states to states
from alpsqutip.operators.states.meanfield import (
    one_body_from_qutip_operator,
    project_to_n_body_operator,
    self_consistent_quadratic_mfa,
)


def safe_expm_and_normalize(op):
    return safe_exp_and_normalize(op)


def commutator(op1, op2):
    """
    Computes the commutator of two operators, defined as [op1, op2] = op1 * op2 - op2 * op1.

    Parameters:
        op1, op2: operators (can be a matrix or a quantum operator object).

    Returns:
        The commutator of op1 and op2.
    """
    return op1 * op2 - op2 * op1


def anticommutator(op1, op2):
    """
    Computes the anticommutator of two operators, defined as {op1, op2} = op1 * op2 + op2 * op1.

    Parameters:
        op1, op2: operators (can be a matrix or a quantum operator object).

    Returns:
        The anticommutator of op1 and op2.
    """
    return op1 * op2 + op2 * op1


def fetch_covar_scalar_product(sigma):
    """
    Returns a scalar product function based on the covariance of a density operator.

    The scalar product for two operators op1 and op2 is defined as:
        0.5 * Tr(sigma * {op1†, op2}),
    where sigma is a density operator, {op1†, op2} is the anticommutator of
    the Hermitian conjugate of op1 and op2, and Tr denotes the trace.

    Parameters:
        sigma: The density operator (quantum state) used to define the scalar product.

    Returns:
        A function that takes two operators (op1, op2) and computes their
        covariance-based scalar product.
    """
    return lambda op1, op2: 0.5 * (sigma * anticommutator(op1.dag(), op2)).tr()


def build_Hierarch(generator, seed_op, deep):
    """
    Constructs a hierarchical basis of operators, formed from iterated commutators of a seed operator.

    Parameters:
        generator: The generator operator (e.g., a Hamiltonian).
                    It should be passed as a QutipAlps operator (not Qutip.qobj)
        seed_op: The initial seed operator for generating the basis.
                 If None, the function will return an empty list.
        deep: An integer indicating the depth of the hierarchy (number of iterated commutators).

    Returns:
        A list of operators representing the hierarchical basis, starting with
        the seed operator, followed by operators generated by successive commutators.
    """
    basis = []
    generator = 1j * generator
    if seed_op is not None and deep > 0:
        basis += [seed_op]  # Include the seed operator in the basis.
        for k in range(deep):
            # Generate new operators by computing the commutator of the generator with the last operator.
            basis.append(commutator(generator, basis[-1]))
    return basis


def fn_Hij_tensor(basis, sp: Callable, generator):
    """
    Computes the Hij-tensor, a local matrix representation of the Hamiltonian onto the given basis.

    For each pair of basis operators (op1, op2), the matrix element is defined as:
        Hij = sp(op1, commutator(-1j * generator, op2))

    Parameters:
        basis: A list of basis operators.
        sp: A callable that defines a scalar product function between two operators.
        generator: The operator (e.g., Hamiltonian) for which the commutators are computed.

    Returns:
        A real-valued NumPy array representing the Hamiltonian matrix in the given basis.
    """
    local_Hij = np.array(
        [[sp(op1, commutator(-1j * generator, op2)) for op2 in basis] for op1 in basis]
    )
    return np.real(local_Hij)


def fn_Hij_tensor_with_errors(basis, sp: Callable, generator):
    """Compute the tensor Hij and the norm of the orthogonal projection"""
    hgen = -1j * generator
    comm_H_ops = [commutator(hgen, op2) for op2 in basis]
    local_Hij = np.array(
        [[sp(op1, comm_op) for comm_op in comm_H_ops] for op1 in basis]
    )
    proj_comm_norms_sq = (sum(col**2) for col in local_Hij.transpose())
    comm_full_norms_sq = (sp(comm_op, comm_op) for comm_op in comm_H_ops)
    errors_w = [
        (max(full_sq - proj_sq, 0.0)) ** 0.5
        for full_sq, proj_sq in zip(comm_full_norms_sq, proj_comm_norms_sq)
    ]
    return local_Hij, errors_w


def gram_matrix(basis, sp: Callable):
    """
    Computes the Gram matrix of a given operator basis using a scalar product.

    The Gram matrix is symmetric and defined as:
        Gij = sp(op1, op2)
    where `sp` is the scalar product function and `op1, op2` are operators from the basis.

    Parameters:
        basis: A list of basis operators.
        sp: A callable that defines a scalar product function between two operators.

    Returns:
        A symmetric NumPy array representing the Gram matrix, with entries rounded to 14 decimal places.
    """
    size = len(basis)
    result = np.zeros([size, size], dtype=float)

    for i, op1 in enumerate(basis):
        for j, op2 in enumerate(basis):
            if j < i:
                continue  # Use symmetry: Gij = Gji.
            entry = np.real(sp(op1, op2))
            if i == j:
                result[i, i] = entry  # Diagonal elements.
            else:
                result[i, j] = result[j, i] = entry  # Off-diagonal elements.

    return result.round(14)


def orthogonalize_basis(basis, sp: callable, tol=1e-5):
    """
    Orthogonalize a given basis of operators using the default method.

    Parameters:
        basis: A list of operators (or matrices) to be orthogonalized.
        sp: A callable that defines the scalar product function between two operators.
        tol: A tolerance value (default: 1e-5) for verifying the orthogonality of the resulting basis.

    Returns:
        orth_basis: A list of orthogonalized operators, normalized with respect to the scalar product `sp`.

    Raises:
        AssertionError: If the orthogonalized basis does not satisfy orthonormality within the specified tolerance.
    """
    return orthogonalize_basis_gs(basis, sp, tol)


def orthogonalize_basis_gs(basis, sp: callable, tol=1e-5):
    """
    Orthogonalizes a given basis of operators using a scalar product and the Gram-Schmidt method.

    Parameters:
        basis: A list of operators (or matrices) to be orthogonalized.
        sp: A callable that defines the scalar product function between two operators.
        tol: A tolerance value (default: 1e-5) for verifying the orthogonality of the resulting basis.

    Returns:
        orth_basis: A list of orthogonalized operators, normalized with respect to the scalar product `sp`.

    Raises:
        AssertionError: If the orthogonalized basis does not satisfy orthonormality within the specified tolerance.
    """
    orth_basis = []
    for op_orig in basis:
        norm = np.real(sp(op_orig, op_orig)) ** 0.5
        if norm < tol:
            continue
        changed = False
        new_op = op_orig / norm
        for prev_op in orth_basis:
            overlap = sp(prev_op, new_op)
            if abs(overlap) > tol:
                new_op -= prev_op * overlap
                changed = True
        if changed:
            norm = np.real(sp(new_op, new_op)) ** 0.5
            if norm < tol:
                continue
            new_op = new_op / norm
        orth_basis.append(new_op)
    return orth_basis


def orthogonalize_basis_cholesky(basis, sp: callable, tol=1e-5):
    """
    Orthogonalizes a given basis of operators using a scalar product and the Cholesky decomposition
    method.

    Parameters:
        basis: A list of operators (or matrices) to be orthogonalized.
        sp: A callable that defines the scalar product function between two operators.
        tol: A tolerance value (default: 1e-5) for verifying the orthogonality of the resulting basis.

    Returns:
        orth_basis: A list of orthogonalized operators, normalized with respect to the scalar product `sp`.

    Raises:
        AssertionError: If the orthogonalized basis does not satisfy orthonormality within the specified tolerance.
    """
    local_basis = basis

    # Compute the inverse Gram matrix for the given basis
    cholesky_gram_matrix = linalg.cholesky(
        gram_matrix(basis=local_basis, sp=sp), lower=False
    )
    linv_t = linalg.inv(cholesky_gram_matrix).transpose()

    # Construct the orthogonalized basis by linear combinations of the original basis
    orth_basis = [
        sum(local_basis[s] * linv_t[i, s] for s in range(i + 1))
        for i in range(len(local_basis))
    ]

    # Verify the orthogonality by checking that the Gram matrix is approximately the identity matrix
    assert (
        linalg.norm(gram_matrix(basis=orth_basis, sp=sp) - np.identity(len(orth_basis)))
        < tol
    ), "Error: Basis not correctly orthogonalized"

    return orth_basis


def orthogonalize_basis_svd(basis, sp: callable, tol=1e-5):
    """
    Orthogonalizes a given basis of operators using a scalar product and the svd decomposition
    method.

    Parameters:
        basis: A list of operators (or matrices) to be orthogonalized.
        sp: A callable that defines the scalar product function between two operators.
        tol: A tolerance value (default: 1e-5) for verifying the orthogonality of the resulting basis.

    Returns:
        orth_basis: A list of orthogonalized operators, normalized with respect to the scalar product `sp`.

    Raises:
        AssertionError: If the orthogonalized basis does not satisfy orthonormality within the specified tolerance.
    """
    local_basis = basis

    # Compute the inverse Gram matrix for the given basis
    inv_gram_matrix = linalg.inv(gram_matrix(basis=local_basis, sp=sp))

    # Construct the orthogonalized basis by linear combinations of the original basis
    orth_basis = [
        sum(
            linalg.sqrtm(inv_gram_matrix)[j][i] * local_basis[j]
            for j in range(len(local_basis))
        )
        for i in range(len(local_basis))
    ]

    # Verify the orthogonality by checking that the Gram matrix is approximately the identity matrix
    assert (
        linalg.norm(gram_matrix(basis=orth_basis, sp=sp) - np.identity(len(orth_basis)))
        < tol
    ), "Error: Basis not correctly orthogonalized"

    return orth_basis


def project_op(op, orthogonal_basis, sp: Callable):
    """
    Projects an operator onto an orthogonal basis using a scalar product.

    This computes the components of the orthogonal projection of `op`
    over the basis `orthogonal_basis` with respect to the scalar product `sp`.

    Parameters:
        op: The operator to be projected (e.g., a matrix or quantum operator).
        orthogonal_basis: A list of orthogonalized operators to serve as the projection basis.
        sp: A callable that defines the scalar product function between two operators.

    Returns:
        A NumPy array containing the projection coefficients, where the i-th coefficient
        represents the projection of `op` onto the i-th element of `orthogonal_basis`.
    """
    return np.array([sp(op2, op) for op2 in orthogonal_basis])


def Kstate_from_phi_basis(phi: np.array, basis):
    """
    Constructs the operator K from a given set of coefficients and basis operators.

    Parameters:
        phi: A NumPy array containing the coefficients for the linear combination.
        basis: A list of basis operators.

    Returns:
        The operator K, defined as the negative linear combination of the basis
        operators weighted by the coefficients in `phi`. If `phi` is shorter than
        the basis, it is padded with zeros.
    """
    if len(phi) < len(basis):
        phi = np.array(list(phi) + [0.0 for _ in range(len(basis) - len(phi))])
    return -sum(phi_a * opa for phi_a, opa in zip(phi, basis))


def mft_state_it(K, sigma, max_it):
    """
    Iteratively computes the one-body component from a QuTip operator and state using a self-consistent Mean-Field Projection (MF).

    Parameters:
        K: The initial operator, a QuTip.Qobj, to be decomposed into one-body components.
        sigma: The referential state to be used in the calculations.
        max_it: Maximum number of iterations.

    Returns:
        A tuple (K_one_body, sigma_one_body):
        - K_one_body: The one-body component of the operator K, an AlpsQuTip.one_body_operator object.
        - sigma_one_body: The one-body state normalized through the MFT process.
    """

    for i in range(max_it):
        K_one_body = one_body_from_qutip_operator(K).terms[1]
        sigma_one_body = safe_exp_and_normalize(K_one_body)[0]
    return K_one_body, sigma_one_body


def slice_times(tlist: np.array, tcuts):
    """
    Divides a time list (`tlist`) into slices based on a sequence of cutoff times (`tcuts`).

    Parameters:
        tlist: A NumPy array of time values to be sliced.
        tcuts: A list or array of cutoff times used to define the time slices.

    Returns:
        A list of NumPy arrays, where each array corresponds to a segment of `tlist`
        based on the intervals defined by `tcuts`.
        - The first slice includes times up to `tcuts[1]`.
        - Subsequent slices include times between `tcuts[d-1]` and `tcuts[d]`.
        - If there are remaining times beyond `tcuts[-1]`, they are included in the last slice.
    """
    sliced_times = [np.array([t for t in tlist if t <= tcuts[1]])]

    for d in range(2, len(tcuts)):
        local_tlist = np.array([t for t in tlist if tcuts[d - 1] <= t <= tcuts[d]])
        sliced_times.append(local_tlist)

    if tlist[-1] > tcuts[-1]:
        sliced_times.append(np.array([t for t in tlist if t >= tcuts[-1]]))

    return sliced_times


m_th_partial_sum = lambda phi, m=int: sum(abs(phi_n) ** 2 for phi_n in phi[-m:])
"""
Computes the $m$-th partial sum of the squared magnitudes of the last `m` coefficients of `phi`.

Parameters:
    phi: A NumPy array containing coefficients.
    m: An integer specifying how many of the last coefficients to include in the sum.

Returns:
    The partial sum of the squared magnitudes of the last `m` coefficients in `phi`.
"""
